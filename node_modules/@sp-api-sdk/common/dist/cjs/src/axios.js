"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAxiosInstance = void 0;
const tslib_1 = require("tslib");
const aws4_axios_1 = require("aws4-axios");
const axios_1 = tslib_1.__importDefault(require("axios"));
const axios_logger_1 = require("axios-logger");
const axios_retry_1 = tslib_1.__importDefault(require("axios-retry"));
const auth_1 = require("@sp-api-sdk/auth");
const errors_1 = require("./errors");
const regions_1 = require("./regions");
const package_1 = require("./utils/package");
function createAxiosInstance({ auth, restrictedDataToken, region, userAgent = `${package_1.packageJson.name}/${package_1.packageJson.version}`, sandbox = false, rateLimiting, logging, }, rateLimits) {
    const regionConfiguration = regions_1.sellingPartnerRegions[region];
    if (!regionConfiguration) {
        throw new TypeError(`Unknown or unsupported region: ${region}`);
    }
    const instance = axios_1.default.create({
        headers: {
            'user-agent': userAgent,
        },
    });
    const endpoint = regionConfiguration.endpoints[sandbox ? 'sandbox' : 'production'];
    if (rateLimiting?.retry) {
        (0, axios_retry_1.default)(instance, {
            retryCondition: (error) => error.response?.status === 429,
            retryDelay(retryCount, error) {
                const url = new URL(error.config.url);
                const method = error.config.method?.toLowerCase();
                const amznRateLimit = Number.parseFloat(error.response?.headers['x-amzn-ratelimit-limit'] ?? '');
                const rateLimit = Number.isNaN(amznRateLimit)
                    ? rateLimits.find((rateLimit) => rateLimit.method.toLowerCase() === method && rateLimit.urlRegex.exec(url.pathname))?.rate
                    : amznRateLimit;
                const delay = rateLimit ? (1 / rateLimit) * 1000 + 1500 : 60 * 1000;
                if (rateLimiting.onRetry) {
                    rateLimiting.onRetry({ delay, rateLimit, retryCount, error });
                }
                return delay;
            },
        });
    }
    // Set x-amz-access-token to each request
    instance.interceptors.request.use(async (config) => {
        if (!config.headers) {
            config.headers = {};
        }
        config.headers['x-amz-access-token'] = restrictedDataToken ?? (await auth.accessToken.get());
        return config;
    });
    // Sign each request (should be the last interceptor)
    instance.interceptors.request.use(async (config) => {
        const credentials = await auth.getCredentials();
        if (!credentials) {
            return config;
        }
        return (0, aws4_axios_1.aws4Interceptor)({
            region: regionConfiguration.awsRegion,
            service: 'execute-api',
        }, {
            accessKeyId: credentials.AccessKeyId ?? '',
            secretAccessKey: credentials.SecretAccessKey ?? '',
            sessionToken: credentials.SessionToken,
        })(config);
    });
    instance.interceptors.response.use(async (response) => response, async (error) => {
        if (axios_1.default.isAxiosError(error) && !(error instanceof auth_1.SellingPartnerApiAuthError)) {
            throw new errors_1.SellingPartnerApiError(error);
        }
        throw error;
    });
    if (logging?.request) {
        const requestLoggerOptions = logging.request === true ? undefined : logging.request;
        if (requestLoggerOptions?.headers) {
            console.warn('WARNING: You have enabled logging of request headers, this can leak authentication information, you should disable in production.');
        }
        instance.interceptors.request.use((config) => (0, axios_logger_1.requestLogger)(config, {
            prefixText: `sp-api-sdk/${region}`,
            dateFormat: 'isoDateTime',
            method: true,
            url: true,
            params: false,
            data: true,
            headers: false,
            logger: console.info,
            ...requestLoggerOptions,
        }));
    }
    if (logging?.response) {
        const responseLoggerOptions = logging.response === true ? undefined : logging.response;
        instance.interceptors.response.use((response) => (0, axios_logger_1.responseLogger)(response, {
            prefixText: `sp-api-sdk/${region}`,
            dateFormat: 'isoDateTime',
            status: true,
            statusText: false,
            params: false,
            data: false,
            headers: true,
            logger: console.info,
            ...responseLoggerOptions,
        }));
    }
    if (logging?.error) {
        const errorLoggerOptions = logging.error === true ? undefined : logging.error;
        instance.interceptors.response.use((response) => response, async (error) => (0, axios_logger_1.errorLogger)(error, {
            prefixText: `sp-api-sdk/${region}`,
            dateFormat: 'isoDateTime',
            status: true,
            statusText: false,
            params: false,
            data: false,
            headers: true,
            logger: console.error,
            ...errorLoggerOptions,
        }));
    }
    return { axios: instance, endpoint };
}
exports.createAxiosInstance = createAxiosInstance;
